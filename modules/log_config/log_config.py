import logging.config
import logging, os, pathlib, sys, pprint
from yaml import load, dump, Loader, Dumper


appBasePath = os.path.abspath(pathlib.Path(__file__).resolve().absolute().parents[2])
logConfigPath = os.path.join(pathlib.Path(__file__).resolve().absolute().parents[2], 'config', 'logging.yaml')
loggingBasePath = os.path.join(appBasePath, 'logs')
modulesPath = os.path.join(pathlib.Path(__file__).resolve().absolute().parents[2], 'modules')

# Handler defaults

maxBytes = 100
backupCount = 3
level = 'WARNING'

class LoggingConf(object):
        
    def __init__(self, logConfigPath = logConfigPath):
            
        self.config = None
        # Read the logging.yaml from config directory. This is in try/except because maybe there is no logging.conf.
        try:
            with open(logConfigPath, "r") as confFile:
                self.config = load(confFile, Loader = Loader)
        except Exception as err:
            # print(err)
            print(f"{logConfigPath} does not exist, creating a new one with defaults...")

    def create_log_directories(self):

        # Create base logging directory if it does not exists
        os.mkdir(loggingBasePath) if not (os.path.exists(loggingBasePath) and os.path.isdir(loggingBasePath)) else print("Log directory exists.")

        # Set the log sub-directories and modules list
        self.modules = []
        loggingSubDirs = []
        for item in os.listdir(modulesPath):
            if os.path.isdir(os.path.join(modulesPath, item)) and not item.startswith('__pycache__'):
                self.modules.append(item)
                loggingSubDirs.append(os.path.join(loggingBasePath, item))
                
        # Create logging subdirectories
        for subdir in loggingSubDirs:
            # If the path does not exist and a directory then create the sub log directories
            os.path.exists(subdir) and os.path.isdir(subdir) or os.mkdir(subdir)
    
    def create_logging_conf(self, dynamicPartDict):

        if self.config: return True

        _staticPart = '''
        # DO NOT edit this file directly. Configure parameters under "logging" key in "main.yaml" file instead
        version: 1
        disable_existing_loggers: true
        incremental: false
        formatters:
            default:
                datefmt: '%Y-%m-%d %H:%M:%S'
                format: '{asctime} {levelname} {module} {message}'
                style: '{'
            default-without-module:
                datefmt: '%Y-%m-%d %H:%M:%S'
                format: '{levelname} {module} {asctime} {message}'
                style: '{'
        ''' 

        _staticPartDict = load(stream = _staticPart, Loader = Loader)
        _staticItems = ["__main__", "airports"]

        dynamicPartDict = dynamicPartDict
        

        level = dynamicPartDict["level"]
        maxBytes = dynamicPartDict["maxBytes"]
        backupCount = dynamicPartDict["backupCount"]

        # print(_staticPartDict)

        _items = self.modules
        _items.append("__main__")
        _items.extend(_staticItems)

        # Add handlers
        _handlers = {}
        for _item in _items:

            _filename = f"logs/{_item}/{_item}.log"
            _formatter = "default"
            _class = "logging.handlers.RotatingFileHandler"

            if _item in _staticItems:
                if _item == "__main__":
                    _filename = f"logs/main.log"
                else:
                    _filename = f"logs/{_item}.log"



            _handlers[_item] = {"level": level, "maxBytes": maxBytes, "backupCount": backupCount,
                                   "filename": _filename,
                                   "formatter": _formatter,
                                   "class": _class
                                   }
        
        # Add stream handler to handlers
        _handlers['stream'] = { "class": "logging.StreamHandler",
                               "formatter": _formatter,
                               "level": level,
                               "stream": "ext://sys.stdout"
                               }

        # Add loggers
        _loggers = {}
        for _item in _items:
            if _item not in _staticItems:
                if _item == "csv_parser":
                    _key = f"modules.{_item}.parser"
                else:
                    _key = f"modules.{_item}.{_item}"
            else:
                _key = _item

            _handlersList = ["stream", _item]
            level = level
            _propagate = False

            _loggers[_key] = { "handlers": _handlersList, "level": level, "propagate": _propagate }
        
        
        # pprint.pprint(_handlers)
        # pprint.pprint(_loggers)

        _handlersDict = {"handlers": _handlers}
        _loggersDict = {"loggers": _loggers}

        self.config = {}

        self.config.update(_staticPartDict)
        self.config.update(_handlersDict)
        self.config.update(_loggersDict)
        
        with open(logConfigPath, mode = "w") as file:
            dump(data = self.config, stream = file, Dumper=Dumper)

        # pprint.pprint(self.config)


if __name__ == '__main__':
    
        loggingConfig = LoggingConf(logConfigPath = logConfigPath)
        loggingConfig.create_log_directories()

        logging = {
            'level': 'WARNING',
            'maxBytes': 1000,
            'backupCount': 2
        }


        loggingConfig.create_logging_conf(dynamicPartDict = logging)
        # logging.config.dictConfig(loggingConfig.config)
        # logger = logging.getLogger(__name__)
        # print(logger.name)
        # print(logger.handlers)
        # logger.error("Hello")
        

